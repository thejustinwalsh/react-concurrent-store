/**
 * Demonstrating how a Redux store could be connected to React using
 * `createStore` and `useStoreSelector`.
 */

import { afterEach, beforeEach, describe, expect, it } from "vitest";
import { render, act } from "@testing-library/react";
import { experimental } from "../../index";
import Logger from "../../../test/TestLogger";
import {
  FragmentAstNode,
  FragmentRef,
  RecordSource,
  RelayProvider,
  RelayStore,
  useFragment,
} from "./MiniRelay";
import { memo } from "react";

const { StoreProvider } = experimental;

let logger: Logger;

beforeEach(() => {
  logger = new Logger();
});

afterEach(() => {
  logger.assertLog([]);
});

function initialize(_prev: RecordSource): RecordSource {
  const next = new RecordSource();
  next.set("ROOT", { id: "ROOT", me: "1" });
  next.set("1", { id: "1", name: "Alice", friend: "2" });
  next.set("2", { id: "2", name: "Bob", friend: "1" });
  return next;
}

describe("createStore for a Relay-like state solution", () => {
  it("Minimal example of MiniRelay", async () => {
    const FRAGMENT: FragmentAstNode = {
      kind: "object",
      fieldName: "me",
      selections: [
        { kind: "scalar", fieldName: "id" },
        { kind: "scalar", fieldName: "name" },
        {
          kind: "object",
          fieldName: "friend",
          selections: [
            { kind: "scalar", fieldName: "id" },
            { kind: "scalar", fieldName: "name" },
            {
              kind: "object",
              fieldName: "friend",
              selections: [
                { kind: "scalar", fieldName: "id" },
                { kind: "scalar", fieldName: "name" },
              ],
            },
          ],
        },
      ],
    };
    // Normally generated by Relay compiler
    type FragmentType = {
      me: {
        id: string;
        name: string;
        friend: {
          id: string;
          name: string;
          friend: {
            id: string;
            name: string;
          };
        };
      };
    };
    const store = new RelayStore();
    store.publishAndNotify(initialize);

    const ref = { startingID: "ROOT" };
    function FragmentComponent() {
      logger.log({ type: "render" });
      const data = useFragment<FragmentType>(FRAGMENT, ref);
      return (
        <div>
          Hello! My name is {data.me.name} (id: {data.me.id})
          <br />
          and my friend is {data.me.friend.name} (id: {data.me.friend.id})
          <br />
          and their friend is {data.me.friend.friend.name} (id:{" "}
          {data.me.friend.friend.id})
        </div>
      );
    }

    function App() {
      return (
        <StoreProvider>
          <RelayProvider store={store}>
            <FragmentComponent />
          </RelayProvider>
        </StoreProvider>
      );
    }

    const { asFragment, unmount } = await act(async () => {
      return render(<App />);
    });

    logger.assertLog([{ type: "render" }]);
    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My name is Alice (id: 1)
          <br />
          and my friend is Bob (id: 2)
          <br />
          and their friend is Alice (id: 1)
        </div>
      </DocumentFragment>
    `);

    await act(async () => {
      store.publishAndNotify((prev) => {
        const next = new RecordSource();
        next.set("1", { id: "1", name: "MALICE", friend: "1" });
        return next;
      });
    });
    logger.assertLog([{ type: "render" }]);

    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My name is MALICE (id: 1)
          <br />
          and my friend is MALICE (id: 1)
          <br />
          and their friend is MALICE (id: 1)
        </div>
      </DocumentFragment>
    `);

    unmount();
  });

  it("Avoids rerendering the component if the fragment value computes the same output", async () => {
    const store = new RelayStore();
    store.publishAndNotify(initialize);

    const FRAGMENT: FragmentAstNode = {
      kind: "object",
      fieldName: "me",
      selections: [{ kind: "scalar", fieldName: "id" }],
    };

    type FragmentType = {
      me: {
        id: string;
      };
    };

    const ref = { startingID: "ROOT" };

    function FragmentComponent() {
      logger.log({ type: "render" });
      const data = useFragment<FragmentType>(FRAGMENT, ref);
      return <div>Hello! My id is {data.me.id}</div>;
    }

    function App() {
      return (
        <StoreProvider>
          <RelayProvider store={store}>
            <FragmentComponent />
          </RelayProvider>
        </StoreProvider>
      );
    }

    const { asFragment, unmount } = await act(async () => {
      return render(<App />);
    });

    logger.assertLog([{ type: "render" }]);
    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My id is 1
        </div>
      </DocumentFragment>
    `);

    await act(async () => {
      store.publishAndNotify((prev) => {
        const next = new RecordSource();
        next.set("1", { id: "1", name: "MALICE", friend: "1" });
        return next;
      });
    });

    // Because the fragment only selects `id`, and `id` did not change,
    // the component should not rerender.
    logger.assertLog([]);

    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My id is 1
        </div>
      </DocumentFragment>
    `);

    unmount();
  });

  it.only("Implements structural sharing such that substructures remain referential identical even if parent object change", async () => {
    const store = new RelayStore();
    store.publishAndNotify(initialize);

    const FRAGMENT: FragmentAstNode = {
      kind: "object",
      fieldName: "me",
      selections: [
        { kind: "scalar", fieldName: "name" },
        { kind: "scalar", fieldName: "id" },
        {
          kind: "object",
          fieldName: "friend",
          selections: [{ kind: "spread", alias: "fragment" }],
        },
      ],
    };

    type FragmentType = {
      me: {
        id: string;
        name: string;
        friend: {
          fragment: FragmentRef;
        };
      };
    };

    const ref = { startingID: "ROOT" };
    function FragmentComponent() {
      logger.log({ type: "render" });
      const data = useFragment<FragmentType>(FRAGMENT, ref);

      return (
        <>
          <div>Hello! My name is {data.me.name}</div>
          <div>
            My friend's name is{" "}
            <ChildFragmentComponent user={data.me.friend.fragment} />
          </div>
        </>
      );
    }

    const CHILD_FRAGMENT: FragmentAstNode = {
      kind: "scalar",
      fieldName: "name",
    };

    const ChildFragmentComponent = memo(
      ({ user: userRef }: { user: FragmentRef }) => {
        logger.log({ type: "child-render" });
        const user = useFragment<{ name: string }>(CHILD_FRAGMENT, userRef);
        return user.name;
      },
    );

    function App() {
      return (
        <StoreProvider>
          <RelayProvider store={store}>
            <FragmentComponent />
          </RelayProvider>
        </StoreProvider>
      );
    }

    const { asFragment, unmount } = await act(async () => {
      return render(<App />);
    });

    logger.assertLog([{ type: "render" }, { type: "child-render" }]);
    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My name is Alice
        </div>
        <div>
          My friend's name is Bob
        </div>
      </DocumentFragment>
    `);

    await act(async () => {
      store.publishAndNotify((prev) => {
        const next = new RecordSource();
        next.set("1", { id: "1", name: "MALICE", friend: "2" });
        return next;
      });
    });

    // Because the child fragment id is stable, and the data is structurally
    // shared AND the child component is momoized, the child component does not
    // need to rerender.
    logger.assertLog([{ type: "render" }]);

    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My name is MALICE
        </div>
        <div>
          My friend's name is Bob
        </div>
      </DocumentFragment>
    `);

    unmount();
  });
});
