/**
 * Demonstrating how a Redux store could be connected to React using
 * `createStore` and `useStoreSelector`.
 */

import { afterEach, beforeEach, describe, expect, it } from "vitest";
import { render, act } from "@testing-library/react";
import { experimental } from "../index";
import Logger from "../../test/TestLogger";
import {
  FragmentRef,
  RecordSource,
  RelayProvider,
  RelayStore,
  useFragment,
} from "./MiniRelay";

const { StoreProvider } = experimental;

let logger: Logger;

beforeEach(() => {
  logger = new Logger();
});

afterEach(() => {
  logger.assertLog([]);
});

function initialize(_prev: RecordSource): RecordSource {
  const next = new RecordSource();
  next.set("ROOT", { id: "ROOT", me: "1" });
  next.set("1", { id: "1", name: "Alice", friend: "2" });
  next.set("2", { id: "2", name: "Bob", friend: "1" });
  return next;
}

const FRAGMENT: FragmentRef = {
  startingID: "ROOT",
  fragment: {
    kind: "object",
    fieldName: "me",
    selections: [
      { kind: "scalar", fieldName: "id" },
      { kind: "scalar", fieldName: "name" },
      {
        kind: "object",
        fieldName: "friend",
        selections: [
          { kind: "scalar", fieldName: "id" },
          { kind: "scalar", fieldName: "name" },
          {
            kind: "object",
            fieldName: "friend",
            selections: [
              { kind: "scalar", fieldName: "id" },
              { kind: "scalar", fieldName: "name" },
            ],
          },
        ],
      },
    ],
  },
};

// Normally generated by Relay compiler
type FragmentType = {
  me: {
    id: string;
    name: string;
    friend: {
      id: string;
      name: string;
      friend: {
        id: string;
        name: string;
      };
    };
  };
};

describe("createStore for a Relay-like state solution", () => {
  it("Minimal example of MiniRelay", async () => {
    const store = new RelayStore();
    store.publishAndNotify(initialize);
    store.reactStore.commit(store.reactStore.getState())

    function FragmentComponent() {
      logger.log({type: "render"});
      const data = useFragment<FragmentType>(FRAGMENT);
      return (
        <div>
          Hello! My name is {data.me.name} (id: {data.me.id})
          <br />
          and my friend is {data.me.friend.name} (id: {data.me.friend.id})
          <br />
          and their friend is {data.me.friend.friend.name} (id:{" "}
          {data.me.friend.friend.id})
        </div>
      );
    }

    function App() {
      return (
        <StoreProvider>
          <RelayProvider store={store}>
            <FragmentComponent />
          </RelayProvider>
        </StoreProvider>
      );
    }

    const { asFragment, unmount } = await act(async () => {
      return render(<App />);
    });

    logger.assertLog([{ type: "render" }]);
    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My name is Alice (id: 1)
          <br />
          and my friend is Bob (id: 2)
          <br />
          and their friend is Alice (id: 1)
        </div>
      </DocumentFragment>
    `);

    await act(async () => {
      store.publishAndNotify((prev) => {
        const next = new RecordSource();
        for(const [key, value] of prev._records.entries()) {
          next.set(key, value);
        }
        next.set("1", { id: "1", name: "MALICE", friend: "1" });
        return next;
      });
    });
    logger.assertLog([{ type: "render" }]);

    expect(asFragment()).toMatchInlineSnapshot(`
      <DocumentFragment>
        <div>
          Hello! My name is MALICE (id: 1)
          <br />
          and my friend is MALICE (id: 1)
          <br />
          and their friend is MALICE (id: 1)
        </div>
      </DocumentFragment>
    `);

    unmount();
  });
});
